---
title: Vue
description: Vue.js-specific linting rules for Ultracite.
---

The Vue configuration (`ultracite/vue`) extends the base Ultracite preset with Vue.js-specific linting rules for component structure, data options, computed properties, and reserved keywords.

## Installation

Add the Vue configuration to your `biome.jsonc`:

```jsonc title="biome.jsonc"
{
  "extends": ["ultracite", "ultracite/vue"]
}
```

## Overview

This configuration adds rules specific to Vue.js development:

- **Component Naming**: Enforce multi-word component names
- **Data Structure**: Prevent improper data option declarations
- **Reserved Keywords**: Disallow use of Vue reserved props and keys
- **Duplicate Keys**: Prevent duplicate keys in component options
- **React-Specific Props**: Disallow React-specific props in Vue components

## Vue-Specific Rules

### Nursery

| Rule | Setting | Description |
|------|---------|-------------|
| `noVueDataObjectDeclaration` | `error` | Prevent using object declaration for the `data` option in Vue components. The `data` option must be a function that returns an object. |
| `noVueDuplicateKeys` | `error` | Prevent duplicate keys in Vue component options. Keys in `data`, `computed`, `methods`, etc. must be unique. |
| `noVueReservedKeys` | `error` | Disallow Vue reserved keys like `$data`, `$props`, `$el`, etc. in component options. |
| `noVueReservedProps` | `error` | Disallow Vue reserved props like `key`, `ref`, and `is` as custom component props. |
| `useVueMultiWordComponentNames` | `error` | Enforce multi-word component names to avoid conflicts with HTML elements. Single-word names like `Button` or `Card` should be avoided. |

### Suspicious

| Rule | Setting | Description |
|------|---------|-------------|
| `noReactSpecificProps` | `error` | Disallow React-specific props like `className` and `htmlFor` in Vue. Use `class` and `for` instead. |

## Usage Examples

### Component Naming

```vue
<!-- Bad: Single-word component name -->
<script>
export default {
  name: 'Button',
};
</script>

<!-- Good: Multi-word component name -->
<script>
export default {
  name: 'AppButton',
};
</script>
```

```vue
<!-- Bad: Single-word component name (Composition API) -->
<script setup lang="ts">
// File: Button.vue
</script>

<!-- Good: Multi-word component name (Composition API) -->
<script setup lang="ts">
// File: AppButton.vue or BaseButton.vue
</script>
```

### Data Option Declaration

```vue
<!-- Bad: Object declaration for data -->
<script>
export default {
  data: {
    count: 0,
    message: 'Hello',
  },
};
</script>

<!-- Good: Function that returns object -->
<script>
export default {
  data() {
    return {
      count: 0,
      message: 'Hello',
    };
  },
};
</script>
```

This is crucial because when `data` is an object, it's shared across all instances of the component. Using a function ensures each component instance has its own independent data.

### Reserved Keys

```vue
<!-- Bad: Using Vue reserved keys -->
<script>
export default {
  data() {
    return {
      $data: {},  // Reserved
      $props: {}, // Reserved
      $el: null,  // Reserved
    };
  },
};
</script>

<!-- Good: Using non-reserved keys -->
<script>
export default {
  data() {
    return {
      userData: {},
      userProps: {},
      element: null,
    };
  },
};
</script>
```

### Duplicate Keys

```vue
<!-- Bad: Duplicate keys across options -->
<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  computed: {
    count() {  // Duplicate!
      return this.value * 2;
    },
  },
};
</script>

<!-- Good: Unique keys -->
<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  computed: {
    doubledCount() {
      return this.count * 2;
    },
  },
};
</script>
```

### Reserved Props

```vue
<!-- Bad: Using reserved prop names -->
<script>
export default {
  props: {
    key: String,  // Reserved by Vue
    ref: String,  // Reserved by Vue
    is: String,   // Reserved by Vue
  },
};
</script>

<!-- Good: Using custom prop names -->
<script>
export default {
  props: {
    itemKey: String,
    reference: String,
    componentType: String,
  },
};
</script>
```

### React vs Vue Props

```vue
<!-- Bad: Using React-specific props -->
<template>
  <div className="container">
    <label htmlFor="email">Email</label>
    <input id="email" type="email" />
  </div>
</template>

<!-- Good: Using Vue props -->
<template>
  <div class="container">
    <label for="email">Email</label>
    <input id="email" type="email" />
  </div>
</template>
```

## Why These Rules Matter

### Component Naming

Multi-word component names prevent conflicts with existing and future HTML elements. Vue will warn if you use a single-word name that matches an HTML element.

### Data Function

When `data` is an object instead of a function returning an object, all component instances share the same data object. This leads to state being shared across components unexpectedly.

### Reserved Keywords

Vue uses certain property names internally (like `$data`, `$props`, `$el`). Using these names in your components can cause conflicts and unexpected behavior.

## Combining with Other Configurations

```jsonc title="biome.jsonc"
{
  // Vue with TanStack Router
  "extends": ["ultracite", "ultracite/vue", "ultracite/router"]
}
```

## Customization

To override specific Vue rules:

```jsonc title="biome.jsonc"
{
  "extends": ["ultracite", "ultracite/vue"],
  "linter": {
    "rules": {
      "nursery": {
        "useVueMultiWordComponentNames": "warn"
      }
    }
  }
}
```

## Related Configurations

- [Core Configuration](/core) - Base Ultracite rules
- [Solid Configuration](/solid) - Similar reactive framework
- [Configuration Guide](/configuration) - General configuration options
